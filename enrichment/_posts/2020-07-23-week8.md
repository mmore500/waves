---
layout: post
title: "Week 8: Gotta Go Fast"
author: Emily Dolson, Matthew Andres Moreno, and Santiago Rodriguez
date: 2020-07-23
---

## Pre-Discussion Learning Material

* [CppCon 2019: Andrei Alexandrescu â€œSpeed Is Found In The Minds of People"](https://youtu.be/FJJTYQYB1JQ)
  * the first hour of the talk is most important

## Agenda

* group discussion of Alaxandrescu's talk
* using a profiler
  * Emily Dolson
* using `perf` to measure memory and cpu usage
  * Santiago Rodriguez
* taking and interpreting timings
  * Matthew Andres Moreno
  * using [`std::chrono`](https://en.cppreference.com/w/cpp/chrono) to measure elapsed time
  * `olsen.cpp`
  ~~~cpp
  #include <chrono>
  #include <thread>
  #include <iostream>
  #include <ratio>
  #include <algorithm>
  #include <vector>
  #include <random>

  int schedule_olsen_sleepover_party() {
    // choose two MK & A themed magic numbers...
    // reference: http://sweetie_olsen.tripod.com/sweetieolsen/id21.html
    const std::string mary_kate_color{ "yellow" };
    const std::string ashley_color{ "maroon" };

    const int mary_kate_number{ std::accumulate(
      std::begin(mary_kate_color),
      std::end(mary_kate_color),
      0
    ) };
    const int ashley_number{ std::accumulate(
      std::begin(ashley_color),
      std::end(ashley_color),
      0
    ) };

    // ... define a random distribution using those numbers...
    // adapated from https://stackoverflow.com/a/13445752
    std::mt19937 rng{std::random_device{}()};
    std::uniform_int_distribution<int> sleep_distribution{
      std::min(mary_kate_number, ashley_number),
      std::max(mary_kate_number, ashley_number)
    };
    
    return sleep_distribution(rng);
  }

  int main() {

    // stopwatch begin
    const auto before{
      std::chrono::steady_clock::now()
    };

    // do work  
    // ... sleep for a MK&A-themed duration
    std::this_thread::sleep_for( std::chrono::milliseconds{
      schedule_olsen_sleepover_party()
    } );

    // stopwatch end
    const auto after{
      std::chrono::steady_clock::now()
    };

    // print time elapsed in milliseconds 
    std::cout << std::chrono::duration<
        double,
        std::milli
      >{
        after - before
      }.count() << " milliseconds" << std::endl; 
  }
  ~~~
  * (... compiling `Mary-Kate` & `Ashley` ...)
  ~~~bash
  g++ Olsen.cpp -o Mary-Kate -std=c++17
  g++ Olsen.cpp -o Ashley -std=c++17
  ~~~
  * using `time` to measure elapsed time
  ~~~bash
  echo "Algorithm,Replicate,Seconds" > "olsen-timings.csv"
  for Replicate in {0..9}; do
    echo "Replicate ${Replicate}"
    for Algorithm in Mary-Kate Ashley; do
      echo "Algorithm ${Algorithm}"
      /usr/bin/time -f "%e" -o tmp \
        "./${Algorithm}" \
           > /dev/null 2>&1
      Seconds=$(cat tmp)
      echo "Seconds ${Seconds}"
      echo "${Algorithm},${Replicate},${Seconds}" >> "olsen-timings.csv"
    done
   echo
   echo "!!! <%) Gimme Pizza <%) !!!"
   echo
  done
  ~~~
  * (... example data ...)
  * `olsen-timings.csv`
  ~~~csv
  Algorithm,Replicate,Seconds
  Mary-Kate,0,0.65
  Ashley,0,0.66
  Mary-Kate,1,0.66
  Ashley,1,0.67
  Mary-Kate,2,0.65
  Ashley,2,0.66
  Mary-Kate,3,0.65
  Ashley,3,0.66
  Mary-Kate,4,0.66
  Ashley,4,0.66
  Mary-Kate,5,0.66
  Ashley,5,0.66
  Mary-Kate,6,0.66
  Ashley,6,0.66
  Mary-Kate,7,0.66
  Ashley,7,0.66
  Mary-Kate,8,0.66
  Ashley,8,0.67
  Mary-Kate,9,0.66
  Ashley,9,0.65
  ~~~
  * using [`seaborn`](https://seaborn.pydata.org/) to draw plots with bootstrapped confidence intervals
  ~~~python
  import pandas as pd
  import seaborn as sns
  from matplotlib import pyplot as plt

  df = pd.read_csv('olsen-timings.csv')

  sns.barplot(
    data=df,
    x='Algorithm',
    y='Seconds',
  )

  plt.savefig(
    'timings-by-algorithm.png',
    transparent=True,
    dpi=300,
  )
  ~~~
  * using [`scipy.stats`](https://docs.scipy.org/doc/scipy/reference/stats.html) to perform a [Kruskal-Wallis test](https://en.wikipedia.org/wiki/Kruskal%E2%80%93Wallis_one-way_analysis_of_variance)
  ~~~python
  import scipy.stats as stats
  import pandas as pd

  df = pd.read_csv('data.csv')

  print(
    stats.kruskal(*(
        chunk
        for idx, chunk
        in df.groupby('Algorithm')['Seconds']
    ))
  )
  ~~~

## Conversation Starters/Discussion Questions

1. What did you think was effective about Alaxandrescu's presentation?
   In what ways could it have been more effective?
2. Does `goto` merit continued existence as a keyword?
3. What do you use as a heuristic for balancing optimization and maintainability?
4. To what extent is predicting or understanding why an optimization works important?
   Why?
5. With modern compilers, do less readable/more directive coding approaches still make sense (e.g., `size & 1` to avoid a conditional)?
6. In a detail-rich talk like Alaxandrescu's, how do you decide what to pay attention to?
